name: Add Spent Time to Project Issues on PR Merge

on:
  pull_request:
    branches:
      - dev
      - develop
      - development
    types: [opened, edited, closed]

jobs:
  add-spent-time:
    runs-on: ubuntu-latest
    steps:
      - id: validate-time-and-issues
        name: Add Spent time to linked issues
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.REVIEWER_TOKEN }}
          script: |

            core.setOutput("should_deploy", "false");

            const action = context.payload.action;
            const pr = context.payload.pull_request;
            const isMergeEvent = action === "closed" && pr.merged;

            async function comment(message) {
              console.log(message);
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                body: message,
              });
            }

            async function commentAndExit(message) {
              await comment(message);
              core.setOutput("should_deploy", "false");
              core.setFailed(message);
              return;
            }

            const prBody = pr.body ?? "";

            // --- –ò–∑–≤–ª–µ–∫–∞–µ–º –∑–∞–¥–∞—á–∏ –∏–∑ –±–ª–æ–∫–∞ "## üìÇ –ó–∞–¥–∞—á–∏:" –∏ –Ω–æ–º–µ—Ä–∞ issues ---
            const tasksSectionMatch = prBody.match(/## üìÇ –ó–∞–¥–∞—á–∏:\s*([\s\S]*?)## ‚è∞ –í—Ä–µ–º—è:/i);
            if (!tasksSectionMatch) {
              return await commentAndExit("No tasks block found in PR description, exiting.");
            }

            const tasksSection = tasksSectionMatch[1].replace(/<!--[\s\S]*?-->/g, " ").trim();
            const issueMatches = [...tasksSection.matchAll(/\bClose(?:s)?\s+#(\d+)\b/gi)];
            const uniqueIssueNumbers = [...new Set(issueMatches.map(match => parseInt(match[1], 10)))];

            if (uniqueIssueNumbers.length === 0) {
              return await commentAndExit("No issues referenced in PR description, exiting.");
            }

            if (uniqueIssueNumbers.length > 1) {
              return await commentAndExit("Multiple issues referenced in PR description, exiting.");
            }

            // --- –ò–∑–≤–ª–µ–∫–∞–µ–º –≤—Ä–µ–º—è –∏–∑ –±–ª–æ–∫–∞ "## ‚è∞ –í—Ä–µ–º—è:" –∏ –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ —á–∞—Å—ã ---
            const timeSectionMatch = prBody.match(/## ‚è∞ –í—Ä–µ–º—è:\s*([\s\S]*?)## ü•á –ö–æ–Ω—Ç—Ä–æ–ª—å–Ω—ã–π —á–µ–∫-–ª–∏—Å—Ç:/i);
            if (!timeSectionMatch) {
              return await commentAndExit("No time block found, exiting.");
            }

            const timeSection = timeSectionMatch[1].replace(/<!--[\s\S]*?-->/g, " ").trim();
            const timeMatch = timeSection.match(/\b(?:(\d+(?:\.\d+)?)\s*h)?\s*(?:(\d+(?:\.\d+)?)\s*m)?\b/i);
            if (!timeMatch || (!timeMatch[1] && !timeMatch[2])) {
              return await commentAndExit("No time block found, exiting.");
            }

            const hours = timeMatch[1] ? parseFloat(timeMatch[1]) : 0;
            const minutes = timeMatch[2] ? parseFloat(timeMatch[2]) : 0;
            const totalHours = Math.round((hours + minutes / 60) * 100) / 100;

            console.log(`Total time to add: ${totalHours} hours`);

            const processedIssues = [];

            for (const issueNumber of uniqueIssueNumbers) {

              // --- –ü–æ–ª—É—á–∞–µ–º –∫–∞—Ä—Ç–æ—á–∫—É –≤ Project V2 ---
              const issueQuery = await github.graphql(
                `
                  query($owner: String!, $repo: String!, $issueNumber: Int!) {
                    repository(owner: $owner, name: $repo) {
                      issue(number: $issueNumber) {
                        id
                        projectItems(first: 10) {
                          nodes {
                            id
                            project {
                              id
                              fields(first: 20) {
                                nodes {
                                  ... on ProjectV2Field {
                                    id
                                    name
                                    dataType
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                `,
                { owner: context.repo.owner, repo: context.repo.repo, issueNumber }
              );

              const repoIssue = issueQuery.repository.issue;
              if (!repoIssue) {
                return await commentAndExit(`Issue #${issueNumber}: referenced in PR description but not found, exiting.`);
              }

              const itemNode = repoIssue.projectItems.nodes[0];
              if (!itemNode) {
                return await commentAndExit(`Issue #${issueNumber}: not found in project, exiting.`);
              }

              const spentField = itemNode.project.fields.nodes.find(f => f.name === "Spent");
              if (!spentField) {
                return await commentAndExit(`Issue #${issueNumber}: no Spent field found in project, exiting.`);
              }

              processedIssues.push({
                issueNumber,
                itemId: itemNode.id,
                projectId: itemNode.project.id,
                spentFieldId: spentField.id,
              });
            }

            if (!isMergeEvent) {
              console.log(`Pull request action "${action}" validated successfully; skipping issue updates.`);
              return;
            }

            const flagMarker = `<!--spent-updated-by-pr-${pr.number}-->`;
            const updateLogs = [];
            const skippedLogs = [];

            for (const processedIssue of processedIssues) {
              const { issueNumber, itemId, projectId, spentFieldId } = processedIssue;

              let alreadyUpdated = false;
              const commentsIterator = github.paginate.iterator(
                github.rest.issues.listComments,
                {
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  per_page: 100,
                }
              );

              for await (const response of commentsIterator) {
                if (response.data.some(comment => comment.body?.includes(flagMarker))) {
                  alreadyUpdated = true;
                  break;
                }
              }

              if (alreadyUpdated) {
                const skipMessage = `Issue #${issueNumber}: already updated for PR #${pr.number}, skipping.`;
                console.log(skipMessage);
                skippedLogs.push(skipMessage);
                continue;
              }

              // --- –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–æ–ª—è Spent ---
              const fieldValueQuery = await github.graphql(
                `
                  query($itemId: ID!) {
                    node(id: $itemId) {
                      ... on ProjectV2Item {
                        id
                        fieldValues(first: 20) {
                          nodes {
                            ... on ProjectV2ItemFieldNumberValue {
                              field {
                                ... on ProjectV2FieldCommon {
                                  id
                                  name
                                }
                              }
                              number
                            }
                          }
                        }
                      }
                    }
                  }
                `,
                { itemId }
              );

              const spentFieldValue = fieldValueQuery.node.fieldValues.nodes.find(
                f => f.field?.name === "Spent"
              );

              const currentSpent = spentFieldValue?.number || 0;
              const roundedCurrentSpent = Math.round(currentSpent * 100) / 100;
              const newSpent = Math.round((currentSpent + totalHours) * 100) / 100;

              // --- –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–ª–µ Spent ---
              await github.graphql(
                `
                  mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $value: Float!) {
                    updateProjectV2ItemFieldValue(input: {
                      projectId: $projectId,
                      itemId: $itemId,
                      fieldId: $fieldId,
                      value: { number: $value }
                    }) {
                      projectV2Item {
                        id
                      }
                    }
                  }
                `,
                { projectId, itemId, fieldId: spentFieldId, value: newSpent }
              );

              const issueCommentBody = `${flagMarker}\nSpent updated by PR #${pr.number}: added ${totalHours} hours (Spent ${roundedCurrentSpent} -> ${newSpent}).`;

              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                body: issueCommentBody,
              });

              const updateLog = `Issue #${issueNumber}: added ${totalHours} hours (Spent ${roundedCurrentSpent} -> ${newSpent}).`;
              console.log(updateLog);
              updateLogs.push(updateLog);
            }

            if (updateLogs.length > 0) {
              let summaryComment = `Time tracking updates:\n${updateLogs.map(log => `- ${log}`).join("\n")}`;

              if (skippedLogs.length > 0) {
                summaryComment += `\n\nSkipped updates:\n${skippedLogs.map(log => `- ${log}`).join("\n")}`;
              }

              await comment(summaryComment);
            } else if (skippedLogs.length > 0) {
              console.log(`Skipped updates:\n${skippedLogs.join("\n")}`);
            }

            core.setOutput("should_deploy", "true");

      - name: Trigger Deployment
        if: ${{ github.event.pull_request.merged == true && steps.validate-time-and-issues.outputs.should_deploy == 'true' }}
        run: |
          curl -X GET "${{ secrets.FORGE_DEPLOY_DEV_URL }}"
        shell: bash

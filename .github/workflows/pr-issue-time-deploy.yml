name: Add Spent Time to Project Issues on PR Merge

on:
  pull_request:
    branches:
      - main
      - dev
      - develop
      - development
    types: [opened, edited, closed]

jobs:
  add-spent-time:
    runs-on: ubuntu-latest
    steps:
      - id: validate-time-and-issues
        name: Add Spent time to linked issues
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.REVIEWER_TOKEN }}
          script: |

            core.setOutput("should_deploy", "false");

            const action = context.payload.action;
            const pr = context.payload.pull_request;
            const isMergeEvent = action === "closed" && pr.merged;

            async function comment(message) {
              console.log(message);
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                body: message,
              });
            }

            async function commentAndExit(message) {
              const failureMessage = message.startsWith("‚ùå") ? message : `‚ùå ${message}`;
              await comment(failureMessage);
              core.setOutput("should_deploy", "false");
              core.setFailed(message);
              return;
            }

            const prBody = pr.body ?? "";

            // --- –ò–∑–≤–ª–µ–∫–∞–µ–º –∑–∞–¥–∞—á–∏ –∏–∑ –±–ª–æ–∫–∞ "## üìÇ –ó–∞–¥–∞—á–∏:" –∏ –Ω–æ–º–µ—Ä–∞ issues ---
            const tasksSectionMatch = prBody.match(/## üìÇ –ó–∞–¥–∞—á–∏:\s*([\s\S]*?)## ‚è∞ –í—Ä–µ–º—è:/i);
            if (!tasksSectionMatch) {
              return await commentAndExit("–ù–µ –Ω–∞–π–¥–µ–Ω –±–ª–æ–∫ –∑–∞–¥–∞—á –≤ –æ–ø–∏—Å–∞–Ω–∏–∏ PR. –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ.");
            }

            const tasksSection = tasksSectionMatch[1].replace(/<!--[\s\S]*?-->/g, " ").trim();
            const issueMatches = [...tasksSection.matchAll(/\b(?:close|closes|closed|fix|fixes|fixed|resolve|resolves|resolved)\s+#(\d+)\b/gi)];
            const uniqueIssueNumbers = [...new Set(issueMatches.map(match => parseInt(match[1], 10)))];

            if (uniqueIssueNumbers.length === 0) {
              return await commentAndExit("–í –æ–ø–∏—Å–∞–Ω–∏–∏ PR –Ω–µ —É–∫–∞–∑–∞–Ω—ã –∑–∞–¥–∞—á–∏. –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ.");
            }

            // --- –ò–∑–≤–ª–µ–∫–∞–µ–º –≤—Ä–µ–º—è –∏–∑ –±–ª–æ–∫–∞ "## ‚è∞ –í—Ä–µ–º—è:" –∏ –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ —á–∞—Å—ã ---
            const timeSectionMatch = prBody.match(/## ‚è∞ –í—Ä–µ–º—è:\s*([\s\S]*?)## ü•á –ö–æ–Ω—Ç—Ä–æ–ª—å–Ω—ã–π —á–µ–∫-–ª–∏—Å—Ç:/i);
            if (!timeSectionMatch) {
              return await commentAndExit("–ó–∞—Ç—Ä–∞—á–µ–Ω–Ω–æ–µ –≤—Ä–µ–º—è –Ω–µ —É–∫–∞–∑–∞–Ω–æ.");
            }

            const timeSection = timeSectionMatch[1].replace(/<!--[\s\S]*?-->/g, " ").trim();
            const timeMatch = timeSection.match(/\b(?:(\d+(?:\.\d+)?)\s*h)?\s*(?:(\d+(?:\.\d+)?)\s*m)?\b/i);
            if (!timeMatch || (!timeMatch[1] && !timeMatch[2])) {
              return await commentAndExit("–ó–∞—Ç—Ä–∞—á–µ–Ω–Ω–æ–µ –≤—Ä–µ–º—è –Ω–µ —É–∫–∞–∑–∞–Ω–æ.");
            }

            const hours = timeMatch[1] ? parseFloat(timeMatch[1]) : 0;
            const minutes = timeMatch[2] ? parseFloat(timeMatch[2]) : 0;
            const totalHoursDecimal = hours + minutes / 60;
            const totalHundredths = Math.round(totalHoursDecimal * 100);
            const totalHours = totalHundredths / 100;

            console.log(`–û–±—â–µ–µ –≤—Ä–µ–º—è –∫ –¥–æ–±–∞–≤–ª–µ–Ω–∏—é: ${totalHours} —á`);

            const processedIssues = [];
            const perIssueHundredths = [];

            if (uniqueIssueNumbers.length > 1) {
              const baseHundredths = Math.floor(totalHundredths / uniqueIssueNumbers.length);
              const remainderHundredths = totalHundredths % uniqueIssueNumbers.length;

              for (let index = 0; index < uniqueIssueNumbers.length; index++) {
                const hundredthsForIssue = baseHundredths + (index < remainderHundredths ? 1 : 0);
                perIssueHundredths.push(hundredthsForIssue);
              }
            } else {
              perIssueHundredths.push(totalHundredths);
            }

            for (const issueNumber of uniqueIssueNumbers) {

              // --- –ü–æ–ª—É—á–∞–µ–º –∫–∞—Ä—Ç–æ—á–∫—É –≤ Project V2 ---
              const issueQuery = await github.graphql(
                `
                  query($owner: String!, $repo: String!, $issueNumber: Int!) {
                    repository(owner: $owner, name: $repo) {
                      issue(number: $issueNumber) {
                        id
                        projectItems(first: 10) {
                          nodes {
                            id
                            project {
                              id
                              fields(first: 20) {
                                nodes {
                                  ... on ProjectV2Field {
                                    id
                                    name
                                    dataType
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                `,
                { owner: context.repo.owner, repo: context.repo.repo, issueNumber }
              );

              const repoIssue = issueQuery.repository.issue;
              if (!repoIssue) {
                return await commentAndExit(`–ó–∞–¥–∞—á–∞ #${issueNumber}: —É–∫–∞–∑–∞–Ω–∞ –≤ –æ–ø–∏—Å–∞–Ω–∏–∏ PR, –Ω–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞. –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ.`);
              }

              const itemNode = repoIssue.projectItems.nodes[0];
              if (!itemNode) {
                return await commentAndExit(`–ó–∞–¥–∞—á–∞ #${issueNumber}: –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –≤ –ø—Ä–æ–µ–∫—Ç–µ. –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ.`);
              }

              const spentField = itemNode.project.fields.nodes.find(f => f.name === "Spent");
              if (!spentField) {
                return await commentAndExit(`–ó–∞–¥–∞—á–∞ #${issueNumber}: –Ω–µ –Ω–∞–π–¥–µ–Ω–æ –ø–æ–ª–µ Spent –≤ –ø—Ä–æ–µ–∫—Ç–µ. –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ.`);
              }

              processedIssues.push({
                issueNumber,
                itemId: itemNode.id,
                projectId: itemNode.project.id,
                spentFieldId: spentField.id,
              });
            }

            if (!isMergeEvent) {
              console.log(`–î–µ–π—Å—Ç–≤–∏–µ pull request "${action}" –ø—Ä–æ–≤–µ—Ä–µ–Ω–æ, –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∑–∞–¥–∞—á –ø—Ä–æ–ø—É—â–µ–Ω–æ.`);
              return;
            }

            const flagMarker = `<!--spent-updated-by-pr-${pr.number}-->`;
            const updateLogs = [];
            const skippedLogs = [];

            for (const [index, processedIssue] of processedIssues.entries()) {
              const { issueNumber, itemId, projectId, spentFieldId } = processedIssue;
              const hundredthsToAdd = perIssueHundredths[index];
              const hoursToAdd = hundredthsToAdd / 100;
              const timeToAdd = Math.round(hoursToAdd * 100) / 100;

              let alreadyUpdated = false;
              const commentsIterator = github.paginate.iterator(
                github.rest.issues.listComments,
                {
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  per_page: 100,
                }
              );

              for await (const response of commentsIterator) {
                if (response.data.some(comment => comment.body?.includes(flagMarker))) {
                  alreadyUpdated = true;
                  break;
                }
              }

              if (alreadyUpdated) {
                const skipMessage = `–ó–∞–¥–∞—á–∞ #${issueNumber}: —É–∂–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∞ –¥–ª—è PR #${pr.number}, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º.`;
                console.log(skipMessage);
                skippedLogs.push(skipMessage);
                continue;
              }

              // --- –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–æ–ª—è Spent ---
              const fieldValueQuery = await github.graphql(
                `
                  query($itemId: ID!) {
                    node(id: $itemId) {
                      ... on ProjectV2Item {
                        id
                        fieldValues(first: 20) {
                          nodes {
                            ... on ProjectV2ItemFieldNumberValue {
                              field {
                                ... on ProjectV2FieldCommon {
                                  id
                                  name
                                }
                              }
                              number
                            }
                          }
                        }
                      }
                    }
                  }
                `,
                { itemId }
              );

              const spentFieldValue = fieldValueQuery.node.fieldValues.nodes.find(
                f => f.field?.name === "Spent"
              );

              const currentSpent = spentFieldValue?.number || 0;
              const roundedCurrentSpent = Math.round(currentSpent * 100) / 100;
              const newSpent = Math.round((currentSpent + hoursToAdd) * 100) / 100;

              // --- –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–ª–µ Spent ---
              await github.graphql(
                `
                  mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $value: Float!) {
                    updateProjectV2ItemFieldValue(input: {
                      projectId: $projectId,
                      itemId: $itemId,
                      fieldId: $fieldId,
                      value: { number: $value }
                    }) {
                      projectV2Item {
                        id
                      }
                    }
                  }
                `,
                { projectId, itemId, fieldId: spentFieldId, value: newSpent }
              );

              const issueCommentBody = `${flagMarker}\n–í—Ä–µ–º—è –ø–æ –∑–∞–¥–∞—á–µ –æ–±–Ω–æ–≤–ª–µ–Ω–æ PR #${pr.number}: –¥–æ–±–∞–≤–ª–µ–Ω–æ ${timeToAdd} —á (Spent ${roundedCurrentSpent} -> ${newSpent}).`;

              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                body: issueCommentBody,
              });

              const updateLog = `–ó–∞–¥–∞—á–∞ #${issueNumber}: –¥–æ–±–∞–≤–ª–µ–Ω–æ ${timeToAdd} —á (Spent ${roundedCurrentSpent} -> ${newSpent}).`;
              console.log(updateLog);
              updateLogs.push(updateLog);
            }

            if (updateLogs.length > 0) {
              let summaryComment = `–û–±–Ω–æ–≤–ª–µ–Ω–∏—è –ø–æ —É—á–µ—Ç—É –≤—Ä–µ–º–µ–Ω–∏:\n${updateLogs.map(log => `- ${log}`).join("\n")}`;

              if (skippedLogs.length > 0) {
                summaryComment += `\n\n–ü—Ä–æ–ø—É—â–µ–Ω–Ω—ã–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è:\n${skippedLogs.map(log => `- ${log}`).join("\n")}`;
              }

              await comment(summaryComment);
            } else if (skippedLogs.length > 0) {
              console.log(`–ü—Ä–æ–ø—É—â–µ–Ω–Ω—ã–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è:\n${skippedLogs.join("\n")}`);
            }

            core.setOutput("should_deploy", "true");

      - name: Trigger Deployment
        if: ${{ github.event.pull_request.merged == true && steps.validate-time-and-issues.outputs.should_deploy == 'true' }}
        uses: actions/github-script@v7
        env:
          FORGE_DEPLOY_DEV_URL: ${{ secrets.FORGE_DEPLOY_DEV_URL }}
        with:
          script: |
            const pr = context.payload.pull_request;

            async function comment(message) {
              console.log(message);
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                body: message,
              });
            }

            async function commentAndExit(message) {
              const failureMessage = message.startsWith("‚ùå") ? message : `‚ùå ${message}`;
              await comment(failureMessage);
              core.setOutput("should_deploy", "false");
              core.setFailed(message);
              return;
            }

            try {
              const response = await fetch(process.env.FORGE_DEPLOY_DEV_URL, { method: "GET" });

              if (!response.ok) {
                const responseBody = await response.text();
                const failureDetails = responseBody ? ` –¢–µ–ª–æ –æ—Ç–≤–µ—Ç–∞: ${responseBody}` : "";
                await commentAndExit(
                  `–ó–∞–ø—Ä–æ—Å –Ω–∞ –¥–µ–ø–ª–æ–π –∑–∞–≤–µ—Ä—à–∏–ª—Å—è —Å –æ—à–∏–±–∫–æ–π ${response.status} ${response.statusText}.${failureDetails}`.trim()
                );
                return;
              }

              await comment("üü¢ –î–µ–ø–ª–æ–π —É—Å–ø–µ—à–Ω–æ –∑–∞–ø—É—â–µ–Ω.");
            } catch (error) {
              await commentAndExit(`–ü—Ä–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–∏ –∑–∞–ø—Ä–æ—Å–∞ –Ω–∞ –¥–µ–ø–ª–æ–π –ø—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞: ${error.message}`);
            }
